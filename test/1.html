<!DOCTYPE html>
<html lang="ch">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <script src="https://cdn.bootcss.com/lodash.js/4.17.11/lodash.js"></script>
  <script src="https://cdn.bootcss.com/zepto/1.2.0/zepto.js"></script>
  <script src="https://cdn.bootcss.com/vue/2.5.22/vue.js"></script>
  <script src="https://cdn.bootcss.com/vue-router/3.0.2/vue-router.js"></script>
  <style type="text/css">
  * {
    margin: 0;
    padding: 0;
  }

  body,
  html {
    /*overflow: hidden;*/
    /*height: 90vh;*/
    /*width: 100vw;*/
  }

  #app {
    width: 100vw;
    height: 100vh;
    position: fixed;
  }

  .view-wrap {
    display: flex;
    /*top: 80px;*/

    height: calc(100% - 40px);
    /*white-space: nowrap;*/
    width: 300vw;
    /*max-width: 200vw;*/
  }

  .view-wrap>span {
    width: 100vw;

    height: 70%;

  }

  .navbar {
    display: flex;
    justify-content: space-around;
    font-size: 2em;
    height: 40px;
    /*margin-bottom: 10px;*/
  }


  .left {
    background: red;
  }

  .middle {
    background: lightblue;
  }

  .right {
    background: lightgreen;
  }

  .navbar {
    background: #eee;
  }


  .active {
    color: red;
  }

  </style>
</head>

<body>
  <div id="app" @touchmove="ontouchmove">
    <div class="navbar">
      <div :class="{active:item.name===$route.name}" :key="item.index" v-for="item in navbar" @click="toggleRouter(item)">{{item.name}}</div>
    </div>
    <div class="view-wrap" @touchstart="ontouchstart" @touchmove="ontouchmove" @touchend="ontouchend">
      <transition :css="css" @enter="enter" @after-enter="afterEnter" @leave="leave" @after-leave="afterLeave">
        <router-view></router-view>
      </transition>
    </div>
  </div>
</body>
<script type="text/javascript">
const Left = {
  name: 'left',
  template: `<span class="left">left</span>`
}
const Middle = {
  name: 'middle',
  template: `<span class="middle">middle</span>`
}
const Right = {
  name: 'right',
  template: `<span class="right">right</span>`
}
var router = new VueRouter({
  routes: [
    { name: "left", path: '/left', component: Left, meta: { index: 0 } },
    { name: "middle", path: '/middle', component: Middle, meta: { index: 1 } },
    { name: "right", path: '/right', component: Right, meta: { index: 2 } }
  ]
})

var vm = new Vue({
  el: '#app',
  data: {
    css: true,
    initiated: false,
    oldRoute: null,
    threshold: window.innerWidth / 3,
    index: 0,
    showIndex: 0,
    enterRoute: null,
    fullWidth: window.innerWidth,
    done: [],
    navbar: [
      { name: 'left', path: '/left', index: 0 },
      { name: 'middle', path: '/middle', index: 1 },
      { name: 'right', path: '/right', index: 2 }
    ],
    delay: 1000
  },
  router,
  computed: {
    // threshold() { return this.fullWidth / 3 },

    index0() {
      return this.navbar.find(item => item.name === this.$route.name).index

      // this.enterRoute = {}
    },
  },
  watch: {
    '$route': {
      async handler(newRoute, oldRoute) {
        const vm = this;
        vm.oldRoute = oldRoute
        if (!oldRoute) {
          this.setIndex()
          return
        }
        if (vm.isTouch) {

          return
        }
        console.log(newRoute, oldRoute);
        // body...
        const newIndex = newRoute.meta.index
        const oldIndex = oldRoute.meta.index;
        let offset = 0;
        console.log(newIndex, oldIndex);
        await vm.$nextTick()
        if (newIndex > oldIndex) {
          offset = '-100vw'
        } else {
          vm.$last = $('.view-wrap').children().last().css({ transform: `translateX(-200vw)` })

          offset = '100vw'

        }
        vm.isTransition = true;
        $('.view-wrap').css({ transform: `translateX(${offset})`, transition: 'all 4s' }).bind('transitionend', function(argument) {
          // body...
          vm.$last && vm.$last.css({ transform: `` })
          vm.setTransitionEnd()

          $(this).css({ transform: '', transition: '' }).unbind('transitionend')
        })
      },
      immediate: true
    }
  },
  created() {
    this.oldRoute = this.$route

  },
  methods: {
    toggleRouter(item) {
      // console.log(item);
      if (this.isTransition) {
        return
      }
      this.$router.push(item)
      this.setIndex()
      // return _.clone(item)
    },
    async addSlider(index) {
      let name = this.navbar[index].name

      this.$router.push({ name });
      await this.$nextTick()
    },
    async initTouchSlider(min, max) {
      for (var i = min; i <= max; i++) {
        let name = this.navbar[i].name
        await this.addSlider({ name })
      }

    },
    async ontouchstart(e) {
      console.log('ontouchstart');
      this.isTouch = true;
      // this.css = false;
      this.startX = e.touches[0].pageX;
      this.startY = e.touches[0].pageY;
      const maxIndex = this.navbar.length - 1
      if (this.index === 0) {
        this.minTranslateX = -this.fullWidth;
        this.maxTranslateX = 0;
        this.addSlider(this.index + 1)
      } else if (this.index === maxIndex) {
        this.maxTranslateX = this.fullWidth;
        this.minTranslateX = 0;
        await this.addSlider(this.index - 1)
        $('.view-wrap').children().last().css({ transform: `translateX(${-this.fullWidth*2}px)` })
        // this.initTabSlide(this.index - 1, this.index)

      } else {
        this.minTranslateX = -this.fullWidth;
        this.maxTranslateX = this.fullWidth;

        await this.addSlider(this.index + 1)

        await this.addSlider(this.index - 1)

        $('.view-wrap').children().last().css({ transform: `translateX(${-this.fullWidth*3}px)` })
        // this.maxTranslateX = 0;
        // this.initTabSlide(this.index - 1, this.index + 1)
      }
      // await this.$nextTick()
      this.initiated = true;

    },
    ontouchmove(e) {

      // console.log(this.initiated);
      if (!this.initiated) {
        return
      }
      this.ismoved = true
      const moveX = e.touches[0].pageX - this.startX;
      this.moveX = moveX
      const moveY = e.touches[0].pageX - this.startY;
      this.percent = Math.abs(moveX / this.fullWidth)

      if (this.isTransition || Math.abs(moveX / 2) < Math.abs(moveY)) {
        this.ismoved = false
        // return
      }
      if (moveX < 0 && Math.abs(moveX) > this.threshold) {
        this.showIndex = this.index + 1;
      } else {
        this.showIndex = this.index;

      }
      const translateX = Math.max(this.minTranslateX, Math.min(this.maxTranslateX, moveX)) + 'px'
      // console.log(translateX);
      $('.view-wrap').css({ transform: `translateX(${translateX})` })

    },
    ontouchend() {
      console.log('ontouchend');
      // return false

      const vm = this;
      if (!vm.ismoved || !vm.initiated) {
        return
      }
      vm.isTransition = true
      if (Math.abs(vm.moveX) > vm.threshold) {

        const endOffset = vm.moveX > 0 ? vm.fullWidth : -vm.fullWidth;
        const nextIndex = vm.moveX > 0 ? this.index - 1 : this.index + 1
        const name = this.navbar[nextIndex].name
        $('.view-wrap').css({ transform: `translateX(${endOffset}px)`, transition: `all ${vm.delay * (1 - vm.percent)}ms` }).bind('transitionend', function() {
          vm.setTransitionEnd()

          // vm.$router.push({ name })
          // vm.setTransitionEnd()
          $(this).unbind('transitionend').css({ 'transition': '', transform: '' })
        })
      } else {
        try {
          const delay = vm.delay
          $('.view-wrap').css({ transform: `translateX(0)`, transition: `all ${delay}ms` }).bind('transitionend', function() {
            $(this).unbind('transitionend').css({ 'transition': '', transform: '' })
            // $('.right').css({ transform: '' })
            console.log(vm.moveX);
            vm.$router.push({ name: vm.oldRoute.name })

            vm.$nextTick(vm.setTransitionEnd)
          })


        } catch (err) {
          console.log(err);
        }
      }
      vm.initiated = false


    },
    setTransitionEnd() {
      this.css = true
      this.done.forEach(done => done());
      this.done = []
      // this.enterDone()
      // this.leaveDone()
      this.setIndex()
      this.isTransition = false
      this.isTouch = false;

    },
    findIndex() {
      return this.navbar.find(item => item.name === this.$route.name).index

    },
    setIndex() {
      this.index = this.showIndex = this.navbar.findIndex(item => item.name === this.$route.name)
    },
    enter(el, done) {
      // console.log('enter', done);
      this.enterDone = done;
      this.done.push(done)
      if (this.css) {
        // setTimeout(done, this.delay)
      }
    },
    afterEnter(el) {
      // console.log('afterEnter');
    },
    leave(el, done) {
      // console.log('leave', done);
      this.leaveDone = done
      this.done.push(done)

      if (this.css) {
        // setTimeout(done, this.delay)
      }

    },
    afterLeave() {
      // console.log('afterLeave');

    },
  }
})

</script>

</html>
